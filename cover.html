
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>memory: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_connnetion.go (86.4%)</option>
				
				<option value="file1">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_database.go (100.0%)</option>
				
				<option value="file2">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_datastore.go (85.1%)</option>
				
				<option value="file3">github.com/kkkzoz/oreo/pkg/datastore/memory/mock_memory_connection.go (84.0%)</option>
				
				<option value="file4">github.com/kkkzoz/oreo/pkg/datastore/memory/mock_memory_datastore.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package memory

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
)

type MemoryConnection struct {
        Address   string
        Port      int
        baseURL   string
        transport *http.Transport
}

func NewMemoryConnection(address string, port int) *MemoryConnection <span class="cov8" title="1">{
        return &amp;MemoryConnection{
                Address: address,
                Port:    port,
                baseURL: fmt.Sprintf("http://%s:%d", address, port),
                transport: &amp;http.Transport{
                        MaxIdleConns:        6000,
                        MaxConnsPerHost:     6000,
                        MaxIdleConnsPerHost: 6000,
                        IdleConnTimeout:     60 * time.Second,
                },
        }
}</span>

func (m *MemoryConnection) Connect() error <span class="cov8" title="1">{
        return nil
}</span>

func (m *MemoryConnection) Get(key string, value any) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/get/%s", m.baseURL, key)
        req, _ := http.NewRequest("GET", url, nil)

        httpClient := &amp;http.Client{Transport: m.transport}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("key not found")
        }</span>

        <span class="cov8" title="1">body := util.GetBodyString(response)
        err = json.Unmarshal([]byte(body), value)
        return err</span>
}

func (m *MemoryConnection) Put(key string, value any) error <span class="cov8" title="1">{
        jsonStr := util.ToJSONString(value)
        path := fmt.Sprintf("%s/put/%s", m.baseURL, key)
        baseURL, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">params := url.Values{}
        params.Add("value", jsonStr)
        baseURL.RawQuery = params.Encode()

        req, _ := http.NewRequest("POST", baseURL.String(), nil)

        httpClient := &amp;http.Client{Transport: m.transport}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("put failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryConnection) Delete(key string) error <span class="cov8" title="1">{
        httpClient := &amp;http.Client{Transport: m.transport}
        url := fmt.Sprintf("%s/delete/%s", m.baseURL, key)
        req, _ := http.NewRequest("DELETE", url, nil)
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("delete failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package memory

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/mux"
)

type MemoryDatabase struct {
        mu      sync.Mutex
        Address string
        Port    int
        records map[string]string
        server  http.Server
        MsgChan chan string
}

func NewMemoryDatabase(address string, port int) *MemoryDatabase <span class="cov8" title="1">{
        return &amp;MemoryDatabase{
                Address: address,
                Port:    port,
                records: make(map[string]string),
                MsgChan: make(chan string),
        }
}</span>

func (m *MemoryDatabase) serveGet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        vars := mux.Vars(r)
        key := vars["key"]
        if value, ok := m.records[key]; ok </span><span class="cov8" title="1">{
                fmt.Fprint(w, value)
        }</span> else<span class="cov8" title="1"> {
                // response with 404
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprintf(w, "Key not found")
        }</span>
}

func (m *MemoryDatabase) servePut(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vars := mux.Vars(r)
        key := vars["key"]
        err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Bad request")
                return
        }</span>
        // Access form values
        <span class="cov8" title="1">value := r.FormValue("value")
        if value == "" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Value is empty")
                return
        }</span>

        <span class="cov8" title="1">m.records[key] = value
        fmt.Fprintf(w, "OK")</span>
}

func (m *MemoryDatabase) serveDelete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vars := mux.Vars(r)
        key := vars["key"]
        if _, ok := m.records[key]; ok </span><span class="cov8" title="1">{
                delete(m.records, key)
                fmt.Fprintf(w, "OK")
        }</span> else<span class="cov8" title="1"> {
                // response with 404
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprintf(w, "Key not found")
        }</span>
}

func (m *MemoryDatabase) serveHeartbeat(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        fmt.Fprintf(w, "OK")
}</span>

func (m *MemoryDatabase) Start() error <span class="cov8" title="1">{

        router := mux.NewRouter()
        router.HandleFunc("/get/{key}", m.serveGet).Methods("GET")
        router.HandleFunc("/put/{key}", m.servePut).Methods("POST")
        router.HandleFunc("/delete/{key}", m.serveDelete).Methods("DELETE")
        router.HandleFunc("/heartbeat", m.serveHeartbeat).Methods("GET")

        m.server = http.Server{
                Addr:    fmt.Sprintf("%s:%d", m.Address, m.Port),
                Handler: router,
        }
        return m.server.ListenAndServe()
}</span>

func (m *MemoryDatabase) Stop() <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 1000*time.Millisecond)
        defer cancel()
        m.server.Shutdown(ctx)
        go func() </span><span class="cov8" title="1">{ m.MsgChan &lt;- "Memory database stopped" }</span>()
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package memory

import (
        "cmp"
        "encoding/json"
        "errors"
        "slices"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
        "github.com/kkkzoz/oreo/pkg/config"
        "github.com/kkkzoz/oreo/pkg/txn"
)

type MemoryDatastore struct {
        txn.BaseDataStore
        conn       MemoryConnectionInterface
        readCache  map[string]MemoryItem
        writeCache map[string]MemoryItem
}

type MemoryItem struct {
        Key       string
        Value     string
        TxnId     string
        TxnState  config.State
        TValid    time.Time
        TLease    time.Time
        Prev      string
        isDeleted bool
        Version   int
}

func (m MemoryItem) GetKey() string <span class="cov0" title="0">{
        return m.Key
}</span>

func NewMemoryDatastore(name string, conn MemoryConnectionInterface) *MemoryDatastore <span class="cov8" title="1">{
        return &amp;MemoryDatastore{
                BaseDataStore: txn.BaseDataStore{Name: name},
                conn:          conn,
                readCache:     make(map[string]MemoryItem),
                writeCache:    make(map[string]MemoryItem),
        }
}</span>

func (m *MemoryDatastore) Start() error <span class="cov8" title="1">{
        err := m.conn.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryDatastore) Read(key string, value any) error <span class="cov8" title="1">{

        var item MemoryItem

        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                // if the record is marked as deleted
                if item.isDeleted </span><span class="cov8" title="1">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">return json.Unmarshal([]byte(item.Value), value)</span>
        }

        // if the record is in the readCache
        <span class="cov8" title="1">if item, ok := m.readCache[key]; ok </span><span class="cov0" title="0">{
                return json.Unmarshal([]byte(item.Value), value)
        }</span>

        // else get if from connection
        <span class="cov8" title="1">err := m.conn.Get(key, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if item.TxnState == config.COMMITTED </span><span class="cov8" title="1">{
                return m.readAsCommitted(item, value)
        }</span>
        <span class="cov8" title="1">if item.TxnState == config.PREPARED </span><span class="cov8" title="1">{

                //TODO: what if the state is ABORTED
                _, err := m.Txn.GetTSRState(item.TxnId)
                if err == nil </span><span class="cov8" title="1">{
                        // if TSR exists
                        // roll forward the record
                        item, err = m.rollForward(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return m.readAsCommitted(item, value)</span>
                }
                // if TSR does not exist
                // and if t_lease has expired
                // we should rollback the record
                // because the transaction that modified the record has been aborted
                <span class="cov8" title="1">if item.TLease.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                        // the corresponding transaction is considered ABORTED
                        m.Txn.WriteTSR(item.TxnId, config.ABORTED)
                        item, err := m.rollback(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return m.readAsCommitted(item, value)</span>
                }
                <span class="cov8" title="1">return errors.New("dirty Read")</span>
        }
        <span class="cov0" title="0">return errors.New("key not found")</span>

}

func (m *MemoryDatastore) readAsCommitted(item MemoryItem, value any) error <span class="cov8" title="1">{
        if item.TValid.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                // if the record has been deleted
                if item.isDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">err := json.Unmarshal([]byte(item.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.readCache[item.Key] = item
                return nil</span>
        }
        <span class="cov8" title="1">var preItem MemoryItem
        err := json.Unmarshal([]byte(item.Prev), &amp;preItem)
        if err != nil </span><span class="cov0" title="0">{
                // The transaction needs to be aborted
                return err
        }</span>
        <span class="cov8" title="1">if preItem.TValid.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                // if the record has been deleted
                if preItem.isDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">err := json.Unmarshal([]byte(preItem.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.readCache[item.Key] = preItem
                return nil</span>
        } else<span class="cov8" title="1"> {
                return errors.New("key not found")
        }</span>
}

func (m *MemoryDatastore) Write(key string, value any) error <span class="cov8" title="1">{
        jsonString := util.ToJSONString(value)
        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                item.Value, item.isDeleted = jsonString, false
                m.writeCache[key] = item
                return nil
        }</span>

        <span class="cov8" title="1">var version int
        if item, ok := m.readCache[key]; ok </span><span class="cov8" title="1">{
                version = item.Version
        }</span> else<span class="cov8" title="1"> {
                version = 1
        }</span>
        // else Write a record to the cache
        <span class="cov8" title="1">m.writeCache[key] = MemoryItem{
                Key:       key,
                Value:     jsonString,
                TxnId:     m.Txn.TxnId,
                TValid:    time.Now(),
                TLease:    time.Now().Add(config.LeastTime * time.Millisecond),
                Version:   version,
                isDeleted: false,
        }
        return nil</span>
}

func (m *MemoryDatastore) Prev(key string, record string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (m *MemoryDatastore) Delete(key string) error <span class="cov8" title="1">{
        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                if item.isDeleted </span><span class="cov8" title="1">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">item.isDeleted = true
                m.writeCache[key] = item
                return nil</span>
        }

        // if the record is in the readCache
        // we can get the corresponding version

        <span class="cov8" title="1">version := 0
        if item, ok := m.readCache[key]; ok </span><span class="cov8" title="1">{
                version = item.Version
        }</span> else<span class="cov8" title="1"> {
                // else write a Delete record to the writeCache
                // first we have to get the corresponding version
                // TODO: should we first read into the cache?
                var item MemoryItem
                err := m.conn.Get(key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">version = item.Version</span>
        }

        <span class="cov8" title="1">m.writeCache[key] = MemoryItem{
                Key:       key,
                isDeleted: true,
                TxnId:     m.Txn.TxnId,
                TxnState:  config.COMMITTED,
                TValid:    time.Now(),
                TLease:    time.Now(),
                Version:   version,
        }
        return nil</span>
}

func (m *MemoryDatastore) conditionalUpdate(item txn.Item) error <span class="cov8" title="1">{
        memItem := item.(MemoryItem)

        key := "memory" + memItem.Key
        err := m.Txn.Lock(key, memItem.TxnId, 100*time.Millisecond)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer m.Txn.Unlock(key, memItem.TxnId)

        var oldItem MemoryItem
        err = m.conn.Get(memItem.Key, &amp;oldItem)
        if err != nil </span><span class="cov8" title="1">{
                // this is a new record
                newItem := m.updateMetadata(memItem, MemoryItem{})
                // Write the new item to the data store
                if err = m.conn.Put(newItem.Key, newItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }

        // TODO: 需不需要根据情况 roll forward ?
        <span class="cov8" title="1">if oldItem.TxnState == config.PREPARED </span><span class="cov8" title="1">{
                return errors.New("write conflicted: the record is in PREPARED state")
        }</span>

        // the old item is in COMMITTED state
        <span class="cov8" title="1">if oldItem.Version == memItem.Version </span><span class="cov8" title="1">{
                // we can do nothing when the record is deleted

                // update record's metadata
                newItem := m.updateMetadata(memItem, oldItem)
                // Write the new item to the data store
                if err = m.conn.Put(newItem.Key, newItem); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                return errors.New("write conflicted: the record has been modified by others")
        }</span>
}

func (m *MemoryDatastore) updateMetadata(newItem MemoryItem, oldItem MemoryItem) MemoryItem <span class="cov8" title="1">{
        // clear the Prev field of the old item
        oldItem.Prev = ""
        // update record's metadata
        newItem.Prev = util.ToJSONString(oldItem)
        newItem.Version++
        newItem.TxnState = config.PREPARED
        newItem.TValid = m.Txn.TxnCommitTime
        newItem.TLease = m.Txn.TxnCommitTime.Add(config.LeastTime * time.Millisecond)

        return newItem
}</span>

func (m *MemoryDatastore) Prepare() error <span class="cov8" title="1">{
        records := make([]MemoryItem, 0, len(m.writeCache))
        for _, v := range m.writeCache </span><span class="cov8" title="1">{
                records = append(records, v)
        }</span>
        // sort records by key
        // TODO: global consistent hash order
        <span class="cov8" title="1">slices.SortFunc(
                records, func(i, j MemoryItem) int </span><span class="cov8" title="1">{
                        return cmp.Compare(i.Key, j.Key)
                }</span>,
        )
        <span class="cov8" title="1">for _, v := range records </span><span class="cov8" title="1">{
                err := m.conditionalUpdate(v)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Commit updates the state of records in the data store to COMMITTED.
// It iterates over the write cache and updates each record's state to COMMITTED.
// After updating the records, it clears the write cache.
// Returns an error if there is any issue updating the records or clearing the cache.
func (m *MemoryDatastore) Commit() error <span class="cov8" title="1">{
        // update record's state to the COMMITTED state in the data store
        for _, v := range m.writeCache </span><span class="cov8" title="1">{
                var item MemoryItem
                err := m.conn.Get(v.Key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">item.TxnState = config.COMMITTED
                err = m.conn.Put(v.Key, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // clear the cache
        <span class="cov8" title="1">m.writeCache = make(map[string]MemoryItem)
        m.readCache = make(map[string]MemoryItem)
        return nil</span>
}

// Abort discards the changes made in the current transaction.
// If hasCommitted is false, it clears the write cache.
// If hasCommitted is true, it rolls back the changes made by the current transaction.
// It returns an error if there is any issue during the rollback process.
func (m *MemoryDatastore) Abort(hasCommitted bool) error <span class="cov8" title="1">{

        if !hasCommitted </span><span class="cov0" title="0">{
                m.writeCache = make(map[string]MemoryItem)
                return nil
        }</span>

        <span class="cov8" title="1">for _, v := range m.writeCache </span><span class="cov8" title="1">{
                var item MemoryItem
                err := m.conn.Get(v.Key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // if the record has been modified by this transaction
                <span class="cov8" title="1">curTxnId := m.Txn.TxnId
                if item.TxnId == curTxnId </span><span class="cov8" title="1">{
                        m.rollback(item)
                }</span>
        }
        <span class="cov8" title="1">m.readCache = make(map[string]MemoryItem)
        m.writeCache = make(map[string]MemoryItem)
        return nil</span>
}

func (m *MemoryDatastore) Recover(key string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// rollback overwrites the record with the application data and metadata that found in field Prev
func (m *MemoryDatastore) rollback(item MemoryItem) (MemoryItem, error) <span class="cov8" title="1">{
        var newItem MemoryItem
        err := json.Unmarshal([]byte(item.Prev), &amp;newItem)
        if err != nil </span><span class="cov0" title="0">{
                return MemoryItem{}, err
        }</span>
        <span class="cov8" title="1">err = m.conn.Put(item.Key, newItem)
        if err != nil </span><span class="cov0" title="0">{
                return MemoryItem{}, err
        }</span>

        <span class="cov8" title="1">return newItem, err</span>
}

// rollForward makes the record metadata with COMMITTED state
func (m *MemoryDatastore) rollForward(item MemoryItem) (MemoryItem, error) <span class="cov8" title="1">{
        // var oldItem MemoryItem
        // m.conn.Get(item.Key, &amp;oldItem)
        item.TxnState = config.COMMITTED
        err := m.conn.Put(item.Key, item)
        return item, err
}</span>

// GetName returns the name of the MemoryDatastore.
func (m *MemoryDatastore) GetName() string <span class="cov8" title="1">{
        return m.Name
}</span>

// SetTxn sets the transaction for the MemoryDatastore.
// It takes a pointer to a Transaction as input and assigns it to the Txn field of the MemoryDatastore.
func (m *MemoryDatastore) SetTxn(txn *txn.Transaction) <span class="cov8" title="1">{
        m.Txn = txn
}</span>

func (m *MemoryDatastore) ReadTSR(txnId string) (config.State, error) <span class="cov8" title="1">{
        var txnState config.State
        err := m.conn.Get(txnId, &amp;txnState)
        if err != nil </span><span class="cov8" title="1">{
                return txnState, err
        }</span>
        <span class="cov8" title="1">return txnState, nil</span>
}

// WriteTSR writes the transaction state (txnState) associated with the given transaction ID (txnId) to the memory datastore.
// It returns an error if the write operation fails.
func (m *MemoryDatastore) WriteTSR(txnId string, txnState config.State) error <span class="cov8" title="1">{
        return m.conn.Put(txnId, txnState)
}</span>

// DeleteTSR deletes a transaction with the given transaction ID from the memory datastore.
// It returns an error if the deletion operation fails.
func (m *MemoryDatastore) DeleteTSR(txnId string) error <span class="cov8" title="1">{
        return m.conn.Delete(txnId)
}</span>

// Copy returns a new instance of MemoryDatastore that is a copy of the current datastore.
// The copy shares the same name and connection as the original datastore.
func (m *MemoryDatastore) Copy() txn.Datastore <span class="cov0" title="0">{
        return NewMemoryDatastore(m.Name, m.conn)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package memory

import (
        "fmt"
        "net/http"
        "net/url"

        "github.com/kkkzoz/oreo/internal/util"
)

// MockMemoryConnection is a mock of MemoryConnection
// When Put is called, it will return error when debugCounter is 0
// Semantically, it means `Put()` call will succeed X times
type MockMemoryConnection struct {
        *MemoryConnection
        debugCounter int
        debugFunc    func() error
        isReturned   bool
        callTimes    int
}

func NewMockMemoryConnection(address string, port int, limit int,
        isReturned bool, debugFunc func() error) *MockMemoryConnection <span class="cov8" title="1">{
        conn := NewMemoryConnection(address, port)
        return &amp;MockMemoryConnection{
                MemoryConnection: conn,
                debugCounter:     limit,
                debugFunc:        debugFunc,
                isReturned:       isReturned,
                callTimes:        0,
        }
}</span>

func (m *MockMemoryConnection) Put(key string, value any) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ m.debugCounter--; m.callTimes++ }</span>()
        <span class="cov8" title="1">if m.debugCounter == 0 </span><span class="cov8" title="1">{
                if m.isReturned </span><span class="cov8" title="1">{
                        return m.debugFunc()
                }</span> else<span class="cov0" title="0"> {
                        m.debugFunc()
                }</span>
        }

        <span class="cov8" title="1">jsonStr := util.ToJSONString(value)
        path := fmt.Sprintf("%s/put/%s", m.baseURL, key)
        baseURL, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">params := url.Values{}
        params.Add("value", jsonStr)
        baseURL.RawQuery = params.Encode()

        req, _ := http.NewRequest("POST", baseURL.String(), nil)

        httpClient := &amp;http.Client{}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("put failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package memory

import "github.com/kkkzoz/oreo/pkg/txn"

type MockMemoryDatastore struct {
        MemoryDatastore
}

func NewMockMemoryDatastore(name string, conn *MemoryConnection) *MockMemoryDatastore <span class="cov0" title="0">{
        return &amp;MockMemoryDatastore{
                MemoryDatastore: MemoryDatastore{
                        BaseDataStore: txn.BaseDataStore{Name: name},
                        conn:          conn,
                        readCache:     make(map[string]MemoryItem),
                        writeCache:    make(map[string]MemoryItem),
                },
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
