
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>memory: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_connnetion.go (86.4%)</option>
				
				<option value="file1">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_database.go (100.0%)</option>
				
				<option value="file2">github.com/kkkzoz/oreo/pkg/datastore/memory/memory_datastore.go (85.0%)</option>
				
				<option value="file3">github.com/kkkzoz/oreo/pkg/datastore/memory/mock_memory_connection.go (84.0%)</option>
				
				<option value="file4">github.com/kkkzoz/oreo/pkg/datastore/memory/mock_memory_datastore.go (0.0%)</option>
				
				<option value="file5">github.com/kkkzoz/oreo/pkg/datastore/redis/redis_connection.go (87.8%)</option>
				
				<option value="file6">github.com/kkkzoz/oreo/pkg/datastore/redis/redis_datastore.go (0.0%)</option>
				
				<option value="file7">github.com/kkkzoz/oreo/pkg/datastore/redis/redis_item.go (33.3%)</option>
				
				<option value="file8">github.com/kkkzoz/oreo/pkg/locker/http_locker.go (0.0%)</option>
				
				<option value="file9">github.com/kkkzoz/oreo/pkg/locker/memory_locker.go (100.0%)</option>
				
				<option value="file10">github.com/kkkzoz/oreo/pkg/serializer/gob_serializer.go (100.0%)</option>
				
				<option value="file11">github.com/kkkzoz/oreo/pkg/serializer/json_serializer.go (100.0%)</option>
				
				<option value="file12">github.com/kkkzoz/oreo/pkg/timeoracle/simple_time_oracle.go (47.7%)</option>
				
				<option value="file13">github.com/kkkzoz/oreo/pkg/txn/state_machine.go (70.0%)</option>
				
				<option value="file14">github.com/kkkzoz/oreo/pkg/txn/transaction.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package memory

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
)

type MemoryConnection struct {
        Address   string
        Port      int
        baseURL   string
        transport *http.Transport
}

func NewMemoryConnection(address string, port int) *MemoryConnection <span class="cov8" title="1">{
        return &amp;MemoryConnection{
                Address: address,
                Port:    port,
                baseURL: fmt.Sprintf("http://%s:%d", address, port),
                transport: &amp;http.Transport{
                        MaxIdleConns:        6000,
                        MaxConnsPerHost:     6000,
                        MaxIdleConnsPerHost: 6000,
                        IdleConnTimeout:     60 * time.Second,
                },
        }
}</span>

func (m *MemoryConnection) Connect() error <span class="cov8" title="1">{
        return nil
}</span>

func (m *MemoryConnection) Get(key string, value any) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/get/%s", m.baseURL, key)
        req, _ := http.NewRequest("GET", url, nil)

        httpClient := &amp;http.Client{Transport: m.transport}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("key not found")
        }</span>

        <span class="cov8" title="1">body := util.GetBodyString(response)
        err = json.Unmarshal([]byte(body), value)
        return err</span>
}

func (m *MemoryConnection) Put(key string, value any) error <span class="cov8" title="1">{
        jsonStr := util.ToJSONString(value)
        path := fmt.Sprintf("%s/put/%s", m.baseURL, key)
        baseURL, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">params := url.Values{}
        params.Add("value", jsonStr)
        baseURL.RawQuery = params.Encode()

        req, _ := http.NewRequest("POST", baseURL.String(), nil)

        httpClient := &amp;http.Client{Transport: m.transport}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("put failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryConnection) Delete(key string) error <span class="cov8" title="1">{
        httpClient := &amp;http.Client{Transport: m.transport}
        url := fmt.Sprintf("%s/delete/%s", m.baseURL, key)
        req, _ := http.NewRequest("DELETE", url, nil)
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()
        if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                _, _ = io.CopyN(io.Discard, response.Body, 1024*4)
                return fmt.Errorf("delete failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package memory

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/mux"
)

type MemoryDatabase struct {
        mu      sync.Mutex
        Address string
        Port    int
        records map[string]string
        server  http.Server
        MsgChan chan string
}

func NewMemoryDatabase(address string, port int) *MemoryDatabase <span class="cov8" title="1">{
        return &amp;MemoryDatabase{
                Address: address,
                Port:    port,
                records: make(map[string]string),
                MsgChan: make(chan string),
        }
}</span>

func (m *MemoryDatabase) serveGet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        vars := mux.Vars(r)
        key := vars["key"]
        if value, ok := m.records[key]; ok </span><span class="cov8" title="1">{
                fmt.Fprint(w, value)
        }</span> else<span class="cov8" title="1"> {
                // response with 404
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprintf(w, "Key not found")
        }</span>
}

func (m *MemoryDatabase) servePut(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vars := mux.Vars(r)
        key := vars["key"]
        err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Bad request")
                return
        }</span>
        // Access form values
        <span class="cov8" title="1">value := r.FormValue("value")
        if value == "" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Value is empty")
                return
        }</span>

        <span class="cov8" title="1">m.records[key] = value
        fmt.Fprintf(w, "OK")</span>
}

func (m *MemoryDatabase) serveDelete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        vars := mux.Vars(r)
        key := vars["key"]
        if _, ok := m.records[key]; ok </span><span class="cov8" title="1">{
                delete(m.records, key)
                fmt.Fprintf(w, "OK")
        }</span> else<span class="cov8" title="1"> {
                // response with 404
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprintf(w, "Key not found")
        }</span>
}

func (m *MemoryDatabase) serveHeartbeat(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        fmt.Fprintf(w, "OK")
}</span>

func (m *MemoryDatabase) Start() error <span class="cov8" title="1">{

        router := mux.NewRouter()
        router.HandleFunc("/get/{key}", m.serveGet).Methods("GET")
        router.HandleFunc("/put/{key}", m.servePut).Methods("POST")
        router.HandleFunc("/delete/{key}", m.serveDelete).Methods("DELETE")
        router.HandleFunc("/heartbeat", m.serveHeartbeat).Methods("GET")

        m.server = http.Server{
                Addr:    fmt.Sprintf("%s:%d", m.Address, m.Port),
                Handler: router,
        }
        return m.server.ListenAndServe()
}</span>

func (m *MemoryDatabase) Stop() <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 1000*time.Millisecond)
        defer cancel()
        m.server.Shutdown(ctx)
        go func() </span><span class="cov8" title="1">{ m.MsgChan &lt;- "Memory database stopped" }</span>()
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package memory

import (
        "cmp"
        "encoding/json"
        "errors"
        "slices"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
        "github.com/kkkzoz/oreo/pkg/config"
        "github.com/kkkzoz/oreo/pkg/txn"
)

type MemoryDatastore struct {
        txn.BaseDataStore
        conn       MemoryConnectionInterface
        readCache  map[string]MemoryItem
        writeCache map[string]MemoryItem
}

type MemoryItem struct {
        Key       string
        Value     string
        TxnId     string
        TxnState  config.State
        TValid    time.Time
        TLease    time.Time
        Prev      string
        isDeleted bool
        Version   int
}

func (m MemoryItem) GetKey() string <span class="cov0" title="0">{
        return m.Key
}</span>

func NewMemoryDatastore(name string, conn MemoryConnectionInterface) *MemoryDatastore <span class="cov8" title="1">{
        return &amp;MemoryDatastore{
                BaseDataStore: txn.BaseDataStore{Name: name},
                conn:          conn,
                readCache:     make(map[string]MemoryItem),
                writeCache:    make(map[string]MemoryItem),
        }
}</span>

func (m *MemoryDatastore) Start() error <span class="cov8" title="1">{
        err := m.conn.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryDatastore) Read(key string, value any) error <span class="cov8" title="1">{

        var item MemoryItem

        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                // if the record is marked as deleted
                if item.isDeleted </span><span class="cov8" title="1">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">return json.Unmarshal([]byte(item.Value), value)</span>
        }

        // if the record is in the readCache
        <span class="cov8" title="1">if item, ok := m.readCache[key]; ok </span><span class="cov0" title="0">{
                return json.Unmarshal([]byte(item.Value), value)
        }</span>

        // else get if from connection
        <span class="cov8" title="1">err := m.conn.Get(key, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if item.TxnState == config.COMMITTED </span><span class="cov8" title="1">{
                return m.readAsCommitted(item, value)
        }</span>
        <span class="cov8" title="1">if item.TxnState == config.PREPARED </span><span class="cov8" title="1">{

                //TODO: what if the state is ABORTED
                _, err := m.Txn.GetTSRState(item.TxnId)
                if err == nil </span><span class="cov8" title="1">{
                        // if TSR exists
                        // roll forward the record
                        item, err = m.rollForward(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return m.readAsCommitted(item, value)</span>
                }
                // if TSR does not exist
                // and if t_lease has expired
                // we should rollback the record
                // because the transaction that modified the record has been aborted
                <span class="cov8" title="1">if item.TLease.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                        // the corresponding transaction is considered ABORTED
                        m.Txn.WriteTSR(item.TxnId, config.ABORTED)
                        item, err := m.rollback(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return m.readAsCommitted(item, value)</span>
                }
                <span class="cov8" title="1">return errors.New("dirty Read")</span>
        }
        <span class="cov0" title="0">return errors.New("key not found")</span>

}

func (m *MemoryDatastore) readAsCommitted(item MemoryItem, value any) error <span class="cov8" title="1">{
        if item.TValid.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                // if the record has been deleted
                if item.isDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">err := json.Unmarshal([]byte(item.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.readCache[item.Key] = item
                return nil</span>
        }
        <span class="cov8" title="1">var preItem MemoryItem
        err := json.Unmarshal([]byte(item.Prev), &amp;preItem)
        if err != nil </span><span class="cov0" title="0">{
                // The transaction needs to be aborted
                return err
        }</span>
        <span class="cov8" title="1">if preItem.TValid.Before(m.Txn.TxnStartTime) </span><span class="cov8" title="1">{
                // if the record has been deleted
                if preItem.isDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">err := json.Unmarshal([]byte(preItem.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.readCache[item.Key] = preItem
                return nil</span>
        } else<span class="cov8" title="1"> {
                return errors.New("key not found")
        }</span>
}

func (m *MemoryDatastore) Write(key string, value any) error <span class="cov8" title="1">{
        jsonString := util.ToJSONString(value)
        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                item.Value, item.isDeleted = jsonString, false
                m.writeCache[key] = item
                return nil
        }</span>

        <span class="cov8" title="1">var version int
        if item, ok := m.readCache[key]; ok </span><span class="cov8" title="1">{
                version = item.Version
        }</span> else<span class="cov8" title="1"> {
                version = 1
        }</span>
        // else Write a record to the cache
        <span class="cov8" title="1">m.writeCache[key] = MemoryItem{
                Key:       key,
                Value:     jsonString,
                TxnId:     m.Txn.TxnId,
                TValid:    time.Now(),
                TLease:    time.Now().Add(config.LeastTime * time.Millisecond),
                Version:   version,
                isDeleted: false,
        }
        return nil</span>
}

func (m *MemoryDatastore) Prev(key string, record string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (m *MemoryDatastore) Delete(key string) error <span class="cov8" title="1">{
        // if the record is in the writeCache
        if item, ok := m.writeCache[key]; ok </span><span class="cov8" title="1">{
                if item.isDeleted </span><span class="cov8" title="1">{
                        return errors.New("key not found")
                }</span>
                <span class="cov8" title="1">item.isDeleted = true
                m.writeCache[key] = item
                return nil</span>
        }

        // if the record is in the readCache
        // we can get the corresponding version

        <span class="cov8" title="1">version := 0
        if item, ok := m.readCache[key]; ok </span><span class="cov8" title="1">{
                version = item.Version
        }</span> else<span class="cov8" title="1"> {
                // else write a Delete record to the writeCache
                // first we have to get the corresponding version
                // TODO: should we first read into the cache?
                var item MemoryItem
                err := m.conn.Get(key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">version = item.Version</span>
        }

        <span class="cov8" title="1">m.writeCache[key] = MemoryItem{
                Key:       key,
                isDeleted: true,
                TxnId:     m.Txn.TxnId,
                TxnState:  config.COMMITTED,
                TValid:    time.Now(),
                TLease:    time.Now(),
                Version:   version,
        }
        return nil</span>
}

func (m *MemoryDatastore) conditionalUpdate(item txn.Item) error <span class="cov8" title="1">{
        memItem := item.(MemoryItem)

        key := "memory" + memItem.Key
        err := m.Txn.Lock(key, memItem.TxnId, 100*time.Millisecond)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer m.Txn.Unlock(key, memItem.TxnId)

        var oldItem MemoryItem
        err = m.conn.Get(memItem.Key, &amp;oldItem)
        if err != nil </span><span class="cov8" title="1">{
                // this is a new record
                newItem := m.updateMetadata(memItem, MemoryItem{})
                // Write the new item to the data store
                if err = m.conn.Put(newItem.Key, newItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }

        // TODO: 需不需要根据情况 roll forward ?
        <span class="cov8" title="1">if oldItem.TxnState == config.PREPARED </span><span class="cov8" title="1">{
                return errors.New("write conflicted: the record is in PREPARED state")
        }</span>

        // the old item is in COMMITTED state
        <span class="cov8" title="1">if oldItem.Version == memItem.Version </span><span class="cov8" title="1">{
                // we can do nothing when the record is deleted

                // update record's metadata
                newItem := m.updateMetadata(memItem, oldItem)
                // Write the new item to the data store
                if err = m.conn.Put(newItem.Key, newItem); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                return errors.New("write conflicted: the record has been modified by others")
        }</span>
}

func (m *MemoryDatastore) updateMetadata(newItem MemoryItem, oldItem MemoryItem) MemoryItem <span class="cov8" title="1">{
        // clear the Prev field of the old item
        oldItem.Prev = ""
        // update record's metadata
        newItem.Prev = util.ToJSONString(oldItem)
        newItem.Version++
        newItem.TxnState = config.PREPARED
        newItem.TValid = m.Txn.TxnCommitTime
        newItem.TLease = m.Txn.TxnCommitTime.Add(config.LeastTime * time.Millisecond)

        return newItem
}</span>

func (m *MemoryDatastore) Prepare() error <span class="cov8" title="1">{
        records := make([]MemoryItem, 0, len(m.writeCache))
        for _, v := range m.writeCache </span><span class="cov8" title="1">{
                records = append(records, v)
        }</span>
        // sort records by key
        // TODO: global consistent hash order
        <span class="cov8" title="1">slices.SortFunc(
                records, func(i, j MemoryItem) int </span><span class="cov8" title="1">{
                        return cmp.Compare(i.Key, j.Key)
                }</span>,
        )
        <span class="cov8" title="1">for _, v := range records </span><span class="cov8" title="1">{
                err := m.conditionalUpdate(v)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Commit updates the state of records in the data store to COMMITTED.
// It iterates over the write cache and updates each record's state to COMMITTED.
// After updating the records, it clears the write cache.
// Returns an error if there is any issue updating the records or clearing the cache.
func (m *MemoryDatastore) Commit() error <span class="cov8" title="1">{
        // update record's state to the COMMITTED state in the data store
        for _, v := range m.writeCache </span><span class="cov8" title="1">{
                var item MemoryItem
                err := m.conn.Get(v.Key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">item.TxnState = config.COMMITTED
                err = m.conn.Put(v.Key, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // clear the cache
        <span class="cov8" title="1">m.writeCache = make(map[string]MemoryItem)
        m.readCache = make(map[string]MemoryItem)
        return nil</span>
}

// Abort discards the changes made in the current transaction.
// If hasCommitted is false, it clears the write cache.
// If hasCommitted is true, it rolls back the changes made by the current transaction.
// It returns an error if there is any issue during the rollback process.
func (m *MemoryDatastore) Abort(hasCommitted bool) error <span class="cov8" title="1">{
        if !hasCommitted </span><span class="cov0" title="0">{
                m.writeCache = make(map[string]MemoryItem)
                return nil
        }</span>

        <span class="cov8" title="1">for _, v := range m.writeCache </span><span class="cov8" title="1">{
                var item MemoryItem
                err := m.conn.Get(v.Key, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // if the record has been modified by this transaction
                <span class="cov8" title="1">curTxnId := m.Txn.TxnId
                if item.TxnId == curTxnId </span><span class="cov8" title="1">{
                        m.rollback(item)
                }</span>
        }
        <span class="cov8" title="1">m.writeCache = make(map[string]MemoryItem)
        return nil</span>
}

func (m *MemoryDatastore) Recover(key string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// rollback overwrites the record with the application data and metadata that found in field Prev
func (m *MemoryDatastore) rollback(item MemoryItem) (MemoryItem, error) <span class="cov8" title="1">{
        var newItem MemoryItem
        err := json.Unmarshal([]byte(item.Prev), &amp;newItem)
        if err != nil </span><span class="cov0" title="0">{
                return MemoryItem{}, err
        }</span>
        <span class="cov8" title="1">err = m.conn.Put(item.Key, newItem)
        if err != nil </span><span class="cov0" title="0">{
                return MemoryItem{}, err
        }</span>

        <span class="cov8" title="1">return newItem, err</span>
}

// rollForward makes the record metadata with COMMITTED state
func (m *MemoryDatastore) rollForward(item MemoryItem) (MemoryItem, error) <span class="cov8" title="1">{
        // var oldItem MemoryItem
        // m.conn.Get(item.Key, &amp;oldItem)
        item.TxnState = config.COMMITTED
        err := m.conn.Put(item.Key, item)
        return item, err
}</span>

// GetName returns the name of the MemoryDatastore.
func (m *MemoryDatastore) GetName() string <span class="cov8" title="1">{
        return m.Name
}</span>

// SetTxn sets the transaction for the MemoryDatastore.
// It takes a pointer to a Transaction as input and assigns it to the Txn field of the MemoryDatastore.
func (m *MemoryDatastore) SetTxn(txn *txn.Transaction) <span class="cov8" title="1">{
        m.Txn = txn
}</span>

func (m *MemoryDatastore) ReadTSR(txnId string) (config.State, error) <span class="cov8" title="1">{
        var txnState config.State
        err := m.conn.Get(txnId, &amp;txnState)
        if err != nil </span><span class="cov8" title="1">{
                return txnState, err
        }</span>
        <span class="cov8" title="1">return txnState, nil</span>
}

// WriteTSR writes the transaction state (txnState) associated with the given transaction ID (txnId) to the memory datastore.
// It returns an error if the write operation fails.
func (m *MemoryDatastore) WriteTSR(txnId string, txnState config.State) error <span class="cov8" title="1">{
        return m.conn.Put(txnId, txnState)
}</span>

// DeleteTSR deletes a transaction with the given transaction ID from the memory datastore.
// It returns an error if the deletion operation fails.
func (m *MemoryDatastore) DeleteTSR(txnId string) error <span class="cov8" title="1">{
        return m.conn.Delete(txnId)
}</span>

func (m *MemoryDatastore) Copy() txn.Datastore <span class="cov0" title="0">{
        return NewMemoryDatastore(m.Name, m.conn)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package memory

import (
        "fmt"
        "net/http"
        "net/url"

        "github.com/kkkzoz/oreo/internal/util"
)

// MockMemoryConnection is a mock of MemoryConnection
// When Put is called, it will return error when debugCounter is 0
// Semantically, it means `Put()` call will succeed X times
type MockMemoryConnection struct {
        *MemoryConnection
        debugCounter int
        debugFunc    func() error
        isReturned   bool
        callTimes    int
}

func NewMockMemoryConnection(address string, port int, limit int,
        isReturned bool, debugFunc func() error) *MockMemoryConnection <span class="cov8" title="1">{
        conn := NewMemoryConnection(address, port)
        return &amp;MockMemoryConnection{
                MemoryConnection: conn,
                debugCounter:     limit,
                debugFunc:        debugFunc,
                isReturned:       isReturned,
                callTimes:        0,
        }
}</span>

func (m *MockMemoryConnection) Put(key string, value any) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ m.debugCounter--; m.callTimes++ }</span>()
        <span class="cov8" title="1">if m.debugCounter == 0 </span><span class="cov8" title="1">{
                if m.isReturned </span><span class="cov8" title="1">{
                        return m.debugFunc()
                }</span> else<span class="cov0" title="0"> {
                        m.debugFunc()
                }</span>
        }

        <span class="cov8" title="1">jsonStr := util.ToJSONString(value)
        path := fmt.Sprintf("%s/put/%s", m.baseURL, key)
        baseURL, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">params := url.Values{}
        params.Add("value", jsonStr)
        baseURL.RawQuery = params.Encode()

        req, _ := http.NewRequest("POST", baseURL.String(), nil)

        httpClient := &amp;http.Client{}
        response, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("put failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package memory

import "github.com/kkkzoz/oreo/pkg/txn"

type MockMemoryDatastore struct {
        MemoryDatastore
}

func NewMockMemoryDatastore(name string, conn *MemoryConnection) *MockMemoryDatastore <span class="cov0" title="0">{
        return &amp;MockMemoryDatastore{
                MemoryDatastore: MemoryDatastore{
                        BaseDataStore: txn.BaseDataStore{Name: name},
                        conn:          conn,
                        readCache:     make(map[string]MemoryItem),
                        writeCache:    make(map[string]MemoryItem),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        "github.com/kkkzoz/oreo/pkg/serializer"
        "github.com/redis/go-redis/v9"
)

type RedisConnection struct {
        rdb     *redis.Client
        Address string
        se      serializer.Serializer
}

type ConnectionOptions struct {
        Address  string
        Password string
        se       serializer.Serializer
}

func NewRedisConnection(config *ConnectionOptions) *RedisConnection <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;ConnectionOptions{
                        Address: "localhost:6379",
                }
        }</span>
        <span class="cov8" title="1">if config.Address == "" </span><span class="cov8" title="1">{
                config.Address = "localhost:6379"
        }</span>

        <span class="cov8" title="1">if config.se == nil </span><span class="cov8" title="1">{
                config.se = serializer.NewJSONSerializer()
        }</span>

        <span class="cov8" title="1">return &amp;RedisConnection{
                rdb: redis.NewClient(&amp;redis.Options{
                        Addr:     config.Address,
                        Password: config.Password,
                }),
                Address: config.Address,
                se:      config.se,
        }</span>
}

func (r *RedisConnection) Connect() error <span class="cov8" title="1">{
        return nil
}</span>

// GetItem retrieves the RedisItem for the given key.
func (r *RedisConnection) GetItem(key string) (RedisItem, error) <span class="cov8" title="1">{
        var value RedisItem
        err := r.rdb.HGetAll(context.Background(), key).Scan(&amp;value)
        if err != nil </span><span class="cov0" title="0">{
                return RedisItem{}, err
        }</span>
        // Check if returned value is an empty struct
        <span class="cov8" title="1">if (RedisItem{}) == value </span><span class="cov8" title="1">{
                return RedisItem{}, fmt.Errorf("key not found: %s", key)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

func (r *RedisConnection) PutItem(key string, value RedisItem) error <span class="cov8" title="1">{
        ctx := context.Background()
        _, err := r.rdb.Pipelined(ctx, func(rdb redis.Pipeliner) error </span><span class="cov8" title="1">{
                rdb.HSet(ctx, key, "Key", value.Key)
                rdb.HSet(ctx, key, "Value", value.Value)
                rdb.HSet(ctx, key, "TxnId", value.TxnId)
                rdb.HSet(ctx, key, "TxnState", value.TxnState)
                rdb.HSet(ctx, key, "TValid", value.TValid.Format(time.RFC3339Nano))
                rdb.HSet(ctx, key, "TLease", value.TLease.Format(time.RFC3339Nano))
                rdb.HSet(ctx, key, "Prev", value.Prev)
                rdb.HSet(ctx, key, "IsDeleted", value.IsDeleted)
                rdb.HSet(ctx, key, "Version", value.Version)
                return nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *RedisConnection) ConditionalUpdate(key string, value RedisItem) error <span class="cov8" title="1">{
        ctx := context.Background()
        sha, err := r.rdb.ScriptLoad(ctx, `
        if redis.call('EXISTS', KEYS[1]) == 0 or redis.call('HGET', KEYS[1], 'Version') == ARGV[1] then
        redis.call('HSET', KEYS[1], 'Key', ARGV[2])
        redis.call('HSET', KEYS[1], 'Value', ARGV[3])
        redis.call('HSET', KEYS[1], 'TxnId', ARGV[4])
        redis.call('HSET', KEYS[1], 'TxnState', ARGV[5])
        redis.call('HSET', KEYS[1], 'TValid', ARGV[6])
        redis.call('HSET', KEYS[1], 'TLease', ARGV[7])
        redis.call('HSET', KEYS[1], 'Version', ARGV[8])
        redis.call('HSET', KEYS[1], 'Prev', ARGV[9])
        return redis.call('HGETALL', KEYS[1])
else
        return redis.error_reply('version mismatch')
end
    `).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = r.rdb.EvalSha(ctx, sha, []string{value.Key}, value.Version, value.Key,
                value.Value, value.TxnId, value.TxnState, value.TValid, value.TLease,
                value.Version+1, value.Prev).Result()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *RedisConnection) Get(name string) (string, error) <span class="cov0" title="0">{
        return r.rdb.Get(context.Background(), name).Result()
}</span>

func (r *RedisConnection) Put(name string, value any) error <span class="cov0" title="0">{
        return r.rdb.Set(context.Background(), name, value, 0).Err()
}</span>

func (r *RedisConnection) Delete(name string) error <span class="cov8" title="1">{
        return r.rdb.Del(context.Background(), name).Err()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package redis

import (
        "cmp"
        "encoding/json"
        "errors"
        "slices"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
        "github.com/kkkzoz/oreo/pkg/config"
        "github.com/kkkzoz/oreo/pkg/txn"
)

type RedisDatastore struct {
        txn.BaseDataStore
        conn       RedisConnection
        readCache  map[string]RedisItem
        writeCache map[string]RedisItem
}

func NewRedisDatastore(name string, conn RedisConnection) *RedisDatastore <span class="cov0" title="0">{
        return &amp;RedisDatastore{
                BaseDataStore: txn.BaseDataStore{Name: name},
                conn:          conn,
                readCache:     make(map[string]RedisItem),
                writeCache:    make(map[string]RedisItem),
        }
}</span>

func (r *RedisDatastore) Start() error <span class="cov0" title="0">{
        err := r.conn.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *RedisDatastore) Read(key string, value any) error <span class="cov0" title="0">{

        // if the record is in the writeCache
        if item, ok := r.writeCache[key]; ok </span><span class="cov0" title="0">{
                // if the record is marked as deleted
                if item.IsDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov0" title="0">return json.Unmarshal([]byte(item.Value), value)</span>
        }

        // if the record is in the readCache
        <span class="cov0" title="0">if item, ok := r.readCache[key]; ok </span><span class="cov0" title="0">{
                return json.Unmarshal([]byte(item.Value), value)
        }</span>

        // else get if from connection
        <span class="cov0" title="0">item, err := r.conn.GetItem(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if item.TxnState == config.COMMITTED </span><span class="cov0" title="0">{
                return r.readAsCommitted(item, value)
        }</span>
        <span class="cov0" title="0">if item.TxnState == config.PREPARED </span><span class="cov0" title="0">{

                //TODO: what if the state is ABORTED
                _, err := r.Txn.GetTSRState(item.TxnId)
                if err == nil </span><span class="cov0" title="0">{
                        // if TSR exists
                        // roll forward the record
                        item, err = r.rollForward(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return r.readAsCommitted(item, value)</span>
                }
                // if TSR does not exist
                // and if t_lease has expired
                // we should rollback the record
                // because the transaction that modified the record has been aborted
                <span class="cov0" title="0">if item.TLease.Before(r.Txn.TxnStartTime) </span><span class="cov0" title="0">{
                        // the corresponding transaction is considered ABORTED
                        r.Txn.WriteTSR(item.TxnId, config.ABORTED)
                        item, err := r.rollback(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return r.readAsCommitted(item, value)</span>
                }
                <span class="cov0" title="0">return errors.New("dirty Read")</span>
        }
        <span class="cov0" title="0">return errors.New("key not found")</span>

}

func (r *RedisDatastore) readAsCommitted(item RedisItem, value any) error <span class="cov0" title="0">{
        if item.TValid.Before(r.Txn.TxnStartTime) </span><span class="cov0" title="0">{
                // if the record has been deleted
                if item.IsDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov0" title="0">err := json.Unmarshal([]byte(item.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">r.readCache[item.Key] = item
                return nil</span>
        }
        <span class="cov0" title="0">var preItem RedisItem
        err := json.Unmarshal([]byte(item.Prev), &amp;preItem)
        if err != nil </span><span class="cov0" title="0">{
                // The transaction needs to be aborted
                return err
        }</span>
        <span class="cov0" title="0">if preItem.TValid.Before(r.Txn.TxnStartTime) </span><span class="cov0" title="0">{
                // if the record has been deleted
                if preItem.IsDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov0" title="0">err := json.Unmarshal([]byte(preItem.Value), value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">r.readCache[item.Key] = preItem
                return nil</span>
        } else<span class="cov0" title="0"> {
                return errors.New("key not found")
        }</span>
}

func (r *RedisDatastore) Write(key string, value any) error <span class="cov0" title="0">{
        jsonString := util.ToJSONString(value)
        // if the record is in the writeCache
        if item, ok := r.writeCache[key]; ok </span><span class="cov0" title="0">{
                item.Value, item.IsDeleted = jsonString, false
                r.writeCache[key] = item
                return nil
        }</span>

        <span class="cov0" title="0">var version int
        if item, ok := r.readCache[key]; ok </span><span class="cov0" title="0">{
                version = item.Version
        }</span> else<span class="cov0" title="0"> {
                version = 1
        }</span>
        // else Write a record to the cache
        <span class="cov0" title="0">r.writeCache[key] = RedisItem{
                Key:       key,
                Value:     jsonString,
                TxnId:     r.Txn.TxnId,
                TValid:    time.Now(),
                TLease:    time.Now().Add(config.LeastTime * time.Millisecond),
                Version:   version,
                IsDeleted: false,
        }
        return nil</span>
}

func (r *RedisDatastore) Prev(key string, record string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *RedisDatastore) Delete(key string) error <span class="cov0" title="0">{
        // if the record is in the writeCache
        if item, ok := r.writeCache[key]; ok </span><span class="cov0" title="0">{
                if item.IsDeleted </span><span class="cov0" title="0">{
                        return errors.New("key not found")
                }</span>
                <span class="cov0" title="0">item.IsDeleted = true
                r.writeCache[key] = item
                return nil</span>
        }

        // if the record is in the readCache
        // we can get the corresponding version

        <span class="cov0" title="0">version := 0
        if item, ok := r.readCache[key]; ok </span><span class="cov0" title="0">{
                version = item.Version
        }</span> else<span class="cov0" title="0"> {
                // else write a Delete record to the writeCache
                // first we have to get the corresponding version
                // TODO: should we first read into the cache?
                item, err := r.conn.GetItem(key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">version = item.Version</span>
        }

        <span class="cov0" title="0">r.writeCache[key] = RedisItem{
                Key:       key,
                IsDeleted: true,
                TxnId:     r.Txn.TxnId,
                TxnState:  config.COMMITTED,
                TValid:    time.Now(),
                TLease:    time.Now(),
                Version:   version,
        }
        return nil</span>
}

func (r *RedisDatastore) conditionalUpdate(item txn.Item) error <span class="cov0" title="0">{
        memItem := item.(RedisItem)

        oldItem, err := r.conn.GetItem(memItem.Key)
        if err != nil </span><span class="cov0" title="0">{
                // this is a new record
                newItem := r.updateMetadata(memItem, RedisItem{})
                // Write the new item to the data store
                if err = r.conn.PutItem(newItem.Key, newItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }

        // TODO: 需不需要根据情况 roll forward ?
        <span class="cov0" title="0">if oldItem.TxnState == config.PREPARED </span><span class="cov0" title="0">{
                return errors.New("write conflicted: the record is in PREPARED state")
        }</span>

        // the old item is in COMMITTED state
        <span class="cov0" title="0">if oldItem.Version == memItem.Version </span><span class="cov0" title="0">{
                // we can do nothing when the record is deleted

                // update record's metadata
                newItem := r.updateMetadata(memItem, oldItem)
                // Write the new item to the data store
                if err = r.conn.PutItem(newItem.Key, newItem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                return errors.New("write conflicted: the record has been modified by others")
        }</span>
}

func (r *RedisDatastore) updateMetadata(newItem RedisItem, oldItem RedisItem) RedisItem <span class="cov0" title="0">{
        // clear the Prev field of the old item
        oldItem.Prev = ""
        // update record's metadata
        newItem.Prev = util.ToJSONString(oldItem)
        newItem.Version++
        newItem.TxnState = config.PREPARED
        newItem.TValid = r.Txn.TxnCommitTime
        newItem.TLease = r.Txn.TxnCommitTime.Add(config.LeastTime * time.Millisecond)

        return newItem
}</span>

func (r *RedisDatastore) Prepare() error <span class="cov0" title="0">{
        records := make([]RedisItem, 0, len(r.writeCache))
        for _, v := range r.writeCache </span><span class="cov0" title="0">{
                records = append(records, v)
        }</span>
        // sort records by key
        // TODO: global consistent hash order
        <span class="cov0" title="0">slices.SortFunc(
                records, func(i, j RedisItem) int </span><span class="cov0" title="0">{
                        return cmp.Compare(i.Key, j.Key)
                }</span>,
        )
        <span class="cov0" title="0">for _, v := range records </span><span class="cov0" title="0">{
                err := r.conditionalUpdate(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Commit updates the state of records in the data store to COMMITTED.
// It iterates over the write cache and updates each record's state to COMMITTED.
// After updating the records, it clears the write cache.
// Returns an error if there is any issue updating the records or clearing the cache.
func (r *RedisDatastore) Commit() error <span class="cov0" title="0">{
        // update record's state to the COMMITTED state in the data store
        for _, v := range r.writeCache </span><span class="cov0" title="0">{
                item, err := r.conn.GetItem(v.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">item.TxnState = config.COMMITTED
                err = r.conn.PutItem(v.Key, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // clear the cache
        <span class="cov0" title="0">r.writeCache = make(map[string]RedisItem)
        r.readCache = make(map[string]RedisItem)
        return nil</span>
}

// Abort discards the changes made in the current transaction.
// If hasCommitted is false, it clears the write cache.
// If hasCommitted is true, it rolls back the changes made by the current transaction.
// It returns an error if there is any issue during the rollback process.
func (r *RedisDatastore) Abort(hasCommitted bool) error <span class="cov0" title="0">{
        if !hasCommitted </span><span class="cov0" title="0">{
                r.writeCache = make(map[string]RedisItem)
                return nil
        }</span>

        <span class="cov0" title="0">for _, v := range r.writeCache </span><span class="cov0" title="0">{
                item, err := r.conn.GetItem(v.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // if the record has been modified by this transaction
                <span class="cov0" title="0">curTxnId := r.Txn.TxnId
                if item.TxnId == curTxnId </span><span class="cov0" title="0">{
                        r.rollback(item)
                }</span>
        }
        <span class="cov0" title="0">r.writeCache = make(map[string]RedisItem)
        return nil</span>
}

func (r *RedisDatastore) Recover(key string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// rollback overwrites the record with the application data and metadata that found in field Prev
func (r *RedisDatastore) rollback(item RedisItem) (RedisItem, error) <span class="cov0" title="0">{
        var newItem RedisItem
        err := json.Unmarshal([]byte(item.Prev), &amp;newItem)
        if err != nil </span><span class="cov0" title="0">{
                return RedisItem{}, err
        }</span>
        <span class="cov0" title="0">err = r.conn.PutItem(item.Key, newItem)
        if err != nil </span><span class="cov0" title="0">{
                return RedisItem{}, err
        }</span>

        <span class="cov0" title="0">return newItem, err</span>
}

// rollForward makes the record metadata with COMMITTED state
func (r *RedisDatastore) rollForward(item RedisItem) (RedisItem, error) <span class="cov0" title="0">{
        // var oldItem RedisItem
        // r.conn.Get(item.Key, &amp;oldItem)
        item.TxnState = config.COMMITTED
        err := r.conn.PutItem(item.Key, item)
        return item, err
}</span>

// GetName returns the name of the MemoryDatastore.
func (r *RedisDatastore) GetName() string <span class="cov0" title="0">{
        return r.Name
}</span>

// SetTxn sets the transaction for the MemoryDatastore.
// It takes a pointer to a Transaction as input and assigns it to the Txn field of the MemoryDatastore.
func (r *RedisDatastore) SetTxn(txn *txn.Transaction) <span class="cov0" title="0">{
        r.Txn = txn
}</span>

func (r *RedisDatastore) ReadTSR(txnId string) (config.State, error) <span class="cov0" title="0">{
        var txnState config.State
        state, err := r.conn.Get(txnId)
        txnState = config.State(util.ToInt(state))
        if err != nil </span><span class="cov0" title="0">{
                return txnState, err
        }</span>
        <span class="cov0" title="0">return txnState, nil</span>
}

// WriteTSR writes the transaction state (txnState) associated with the given transaction ID (txnId) to the memory datastore.
// It returns an error if the write operation fails.
func (r *RedisDatastore) WriteTSR(txnId string, txnState config.State) error <span class="cov0" title="0">{
        return r.conn.Put(txnId, util.ToString(txnState))
}</span>

// DeleteTSR deletes a transaction with the given transaction ID from the memory datastore.
// It returns an error if the deletion operation fails.
func (r *RedisDatastore) DeleteTSR(txnId string) error <span class="cov0" title="0">{
        return r.conn.Delete(txnId)
}</span>

func (r *RedisDatastore) Copy() txn.Datastore <span class="cov0" title="0">{
        return NewRedisDatastore(r.Name, r.conn)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package redis

import (
        "fmt"
        "time"

        "github.com/kkkzoz/oreo/internal/util"
        "github.com/kkkzoz/oreo/pkg/config"
)

type RedisItem struct {
        Key       string       `redis:"Key"`
        Value     string       `redis:"Value"`
        TxnId     string       `redis:"TxnId"`
        TxnState  config.State `redis:"TxnState"`
        TValid    time.Time    `redis:"TValid"`
        TLease    time.Time    `redis:"TLease"`
        Prev      string       `redis:"Prev"`
        IsDeleted bool         `redis:"IsDeleted"`
        Version   int          `redis:"Version"`
}

func (m RedisItem) GetKey() string <span class="cov0" title="0">{
        return m.Key
}</span>

func (r RedisItem) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(`RedisItem{
    Key:       %s,
    Value:     %s,
    TxnId:     %s,
    TxnState:  %s,
    TValid:    %s,
    TLease:    %s,
    Prev:      %s,
    IsDeleted: %v,
    Version:   %d,
}`, r.Key, r.Value, r.TxnId, util.ToString(r.TxnState),
                r.TValid.Format(time.RFC3339), r.TLease.Format(time.RFC3339),
                r.Prev, r.IsDeleted, r.Version)
}</span>

func (r *RedisItem) Equal(other RedisItem) bool <span class="cov8" title="1">{
        return r.Key == other.Key &amp;&amp;
                r.Value == other.Value &amp;&amp;
                r.TxnId == other.TxnId &amp;&amp;
                r.TxnState == other.TxnState &amp;&amp;
                r.TValid.Equal(other.TValid) &amp;&amp;
                r.TLease.Equal(other.TLease) &amp;&amp;
                r.Prev == other.Prev &amp;&amp;
                r.IsDeleted == other.IsDeleted &amp;&amp;
                r.Version == other.Version
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package locker

import (
        "errors"
        "net/http"
        "net/url"
        "strconv"
        "time"
)

// HttpLocker represents a locker that uses HTTP requests to interact with an Oracle service.
type HttpLocker struct {
        oracleURL string
}

// NewHttpLocker creates a new instance of HttpLocker with the specified oracleURL.
// The oracleURL parameter is the URL of the Oracle server used for locking.
func NewHttpLocker(oracleURL string) *HttpLocker <span class="cov0" title="0">{
        return &amp;HttpLocker{
                oracleURL: oracleURL,
        }
}</span>

// Lock locks the specified key with the given ID for the specified duration.
// It sends an HTTP GET request to the oracleURL with the key, ID, and duration as query parameters.
// If the lock request fails, it returns an error indicating the failure.
func (l *HttpLocker) Lock(key string, id string, holdDuration time.Duration) error <span class="cov0" title="0">{
        data := url.Values{}
        data.Set("key", key)
        data.Set("id", id)
        data.Set("duration", strconv.Itoa(int(holdDuration)))

        _, err := http.Get(l.oracleURL + "/lock?" + data.Encode())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to lock")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Unlock unlocks the specified key with the given ID using HTTP.
// It sends a GET request to the oracleURL with the key and ID as query parameters.
// If the request is successful, it returns nil. Otherwise, it returns an error.
func (l *HttpLocker) Unlock(key string, id string) error <span class="cov0" title="0">{
        data := url.Values{}
        data.Set("key", key)
        data.Set("id", id)

        _, err := http.Get(l.oracleURL + "/unlock?" + data.Encode())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package locker

import (
        "errors"
        "sync"
        "time"
)

type MemoryLocker struct {
        mu     sync.Mutex
        locks  map[string]string
        cond   *sync.Cond
        timers map[string]*time.Timer
}

var AMemoryLocker = NewMemoryLocker()

// NewMemoryLocker creates a new instance of MemoryLocker.
// MemoryLocker is a type that provides a mechanism for locking and unlocking memory resources.
// It initializes the locks and timers maps and returns a pointer to the newly created MemoryLocker.
func NewMemoryLocker() *MemoryLocker <span class="cov8" title="1">{
        ml := &amp;MemoryLocker{
                locks:  make(map[string]string),
                timers: make(map[string]*time.Timer),
        }
        ml.cond = sync.NewCond(&amp;ml.mu)
        return ml
}</span>

// Lock locks the memory locker for the given key and ID for a specified duration.
// If the memory locker is already locked by someone else, the function will block until it is unlocked.
// Once locked, the memory locker will automatically unlock after the specified hold duration.
// If the lock is released before the hold duration expires, the timer will be stopped.
// After the hold duration expires, the lock will be released and the corresponding timer will be removed.
// The function is thread-safe.
func (ml *MemoryLocker) Lock(key string, id string, holdDuration time.Duration) error <span class="cov8" title="1">{
        ml.mu.Lock()
        defer ml.mu.Unlock()

        for ml.locks[key] != "" &amp;&amp; ml.locks[key] != id </span><span class="cov8" title="1">{
                ml.cond.Wait()
        }</span>

        <span class="cov8" title="1">if timer, ok := ml.timers[key]; ok </span><span class="cov8" title="1">{
                timer.Stop()
        }</span>

        <span class="cov8" title="1">ml.locks[key] = id
        timer := time.AfterFunc(holdDuration, func() </span><span class="cov8" title="1">{
                ml.mu.Lock()
                defer ml.mu.Unlock()
                if ml.locks[key] == id </span><span class="cov8" title="1">{
                        delete(ml.locks, key)
                        delete(ml.timers, key)
                        ml.cond.Broadcast()
                }</span>
        })

        <span class="cov8" title="1">ml.timers[key] = timer
        return nil</span>
}

// Unlock releases the lock for the given key and ID.
// If the ID does not match the one that holds the lock, an error is returned.
// It also stops the timer associated with the key, if any.
// After releasing the lock, it broadcasts a signal to wake up any goroutines waiting on the lock.
func (ml *MemoryLocker) Unlock(key string, id string) error <span class="cov8" title="1">{
        ml.mu.Lock()
        defer ml.mu.Unlock()

        if ml.locks[key] != id </span><span class="cov8" title="1">{
                return errors.New("the id does not match the one that holds the lock")
        }</span>
        <span class="cov8" title="1">delete(ml.locks, key)
        if timer, ok := ml.timers[key]; ok </span><span class="cov8" title="1">{
                timer.Stop()
        }</span>
        <span class="cov8" title="1">delete(ml.timers, key)
        ml.cond.Broadcast()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package serializer

import (
        "bytes"
        "encoding/gob"
)

type GobSerializer struct {
}

func NewGobSerializer() *GobSerializer <span class="cov8" title="1">{
        return &amp;GobSerializer{}
}</span>

func (s *GobSerializer) Serialize(data any) ([]byte, error) <span class="cov8" title="1">{
        var buffer bytes.Buffer
        encoder := gob.NewEncoder(&amp;buffer)
        err := encoder.Encode(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

func (s *GobSerializer) Deserialize(bs []byte, tar any) error <span class="cov8" title="1">{
        buffer := bytes.NewBuffer(bs)
        decoder := gob.NewDecoder(buffer)
        return decoder.Decode(tar)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package serializer

import "encoding/json"

type JSONSerializer struct {
}

func NewJSONSerializer() *JSONSerializer <span class="cov8" title="1">{
        return &amp;JSONSerializer{}
}</span>

func (s *JSONSerializer) Serialize(data any) ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(data)
}</span>

func (s *JSONSerializer) Deserialize(bs []byte, tar any) error <span class="cov8" title="1">{
        return json.Unmarshal(bs, tar)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package timeoracle

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "github.com/kkkzoz/oreo/pkg/locker"
)

// SimpleTimeOracle represents a simple time oracle that provides time-related information.
// It contains the address, port, base URL, server, message channel, and locker.
type SimpleTimeOracle struct {
        // Address is the IP address of the time oracle.
        Address string
        // Port is the port number of the time oracle.
        Port int
        // baseURL is the base URL of the time oracle.
        baseURL string
        // server is the HTTP server used by the time oracle.
        server http.Server
        // MsgChan is the channel used for sending and receiving messages.
        MsgChan chan string
        // locker is used for synchronizing access to the time oracle.
        locker locker.Locker
}

// NewSimpleTimeOracle creates a new instance of SimpleTimeOracle.
func NewSimpleTimeOracle(address string, port int, locker locker.Locker) *SimpleTimeOracle <span class="cov8" title="1">{
        return &amp;SimpleTimeOracle{
                Address: address,
                Port:    port,
                baseURL: fmt.Sprintf("http://%s:%d", address, port),
                MsgChan: make(chan string),
                locker:  locker,
        }
}</span>

// GetTime returns the current time as reported by the SimpleTimeOracle.
func (s *SimpleTimeOracle) GetTime() time.Time <span class="cov8" title="1">{
        return time.Now()
}</span>

func (s *SimpleTimeOracle) serveTime(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        fmt.Fprintf(w, "%s", s.GetTime())
}</span>

func (s *SimpleTimeOracle) serveLock(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Bad request")
                return
        }</span>
        // Access form values
        <span class="cov8" title="1">key := r.FormValue("key")
        id := r.FormValue("id")
        durationStr := r.FormValue("duration")

        // validate
        if key == "" || id == "" || durationStr == "" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Missing parameters")
                return
        }</span>

        <span class="cov8" title="1">duration, err := strconv.Atoi(durationStr)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Invalid duration")
                return
        }</span>
        <span class="cov8" title="1">err = s.locker.Lock(key, id, time.Duration(duration)*time.Millisecond)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Lock failed")
                return
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "OK")</span>
}

func (s *SimpleTimeOracle) serveUnlock(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprint(w, err.Error())
                return
        }</span>
        // Access form values
        <span class="cov8" title="1">key := r.FormValue("key")
        id := r.FormValue("id")

        // validate
        if key == "" || id == "" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprintf(w, "Missing parameters")
                return
        }</span>

        <span class="cov8" title="1">err = s.locker.Unlock(key, id)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                fmt.Fprint(w, err.Error())
                return
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "OK")</span>
}

// Start starts the SimpleTimeOracle server.
// It initializes the router and sets up the necessary routes for serving time, locking, and unlocking.
// It then starts the server and listens for incoming requests.
// Returns an error if there was a problem starting the server.
func (s *SimpleTimeOracle) Start() error <span class="cov0" title="0">{

        router := mux.NewRouter()
        router.HandleFunc("/time", s.serveTime).Methods("GET")
        router.HandleFunc("/lock", s.serveLock).Methods("GET")
        router.HandleFunc("/unlock", s.serveUnlock).Methods("GET")
        s.server = http.Server{
                Addr:    s.baseURL,
                Handler: router,
        }

        return s.server.ListenAndServe()
}</span>

// WaitForStartUp waits for the server to start up by continuously sending HTTP requests to the "/time" endpoint until a successful response is received or the timeout is reached.
// It returns an error if the server does not reply within the specified timeout duration.
func (s *SimpleTimeOracle) WaitForStartUp(timeout time.Duration) error <span class="cov0" title="0">{
        ch := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        _, err := http.Get(s.baseURL + "/time")
                        if err == nil </span><span class="cov0" title="0">{
                                ch &lt;- true
                        }</span>
                        <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-ch:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return fmt.Errorf("server did not reply after %v", timeout)</span>
        }
}

// Stop stops the SimpleTimeOracle server gracefully.
// It shuts down the server and sends a message to the MsgChan indicating that the Simple Time Oracle has stopped.
// It returns an error if there was an issue shutting down the server.
func (s *SimpleTimeOracle) Stop() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 1000*time.Millisecond)
        defer cancel()
        s.server.Shutdown(ctx)
        go func() </span><span class="cov0" title="0">{ s.MsgChan &lt;- "Simple Time Oracle stopped" }</span>()
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package txn

import (
        "errors"
        "fmt"

        "github.com/kkkzoz/oreo/pkg/config"
)

type StateMachine struct {
        state config.State
}

func NewStateMachine() *StateMachine <span class="cov8" title="1">{
        return &amp;StateMachine{
                state: config.EMPTY,
        }
}</span>

func (st *StateMachine) SetState(state config.State) error <span class="cov8" title="1">{
        switch state </span>{
        case config.STARTED:<span class="cov8" title="1">
                if st.state != config.EMPTY </span><span class="cov8" title="1">{
                        return errors.New("transaction can't be started as it is not in an empty state")
                }</span>
        case config.COMMITTED:<span class="cov8" title="1">
                if st.state != config.STARTED </span><span class="cov8" title="1">{
                        return errors.New("transaction can only be committed from a started state")
                }</span>
        case config.ABORTED:<span class="cov0" title="0">
                if st.state == config.EMPTY </span><span class="cov0" title="0">{
                        return errors.New("transaction can't be aborted as it hasn't been started yet")
                }</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("attempted to transition to invalid state %v", state)</span>
        }

        <span class="cov8" title="1">st.state = state
        return nil</span>
}

func (st *StateMachine) CheckState(state config.State) error <span class="cov8" title="1">{
        if st.state != state </span><span class="cov8" title="1">{
                switch state </span>{
                case config.EMPTY:<span class="cov0" title="0">
                        return errors.New("the transaction hasn't been started yet")</span>
                case config.STARTED:<span class="cov8" title="1">
                        return errors.New("the transaction is not currently in progress")</span>
                case config.COMMITTED:<span class="cov0" title="0">
                        return errors.New("the transaction has not been committed yet")</span>
                case config.ABORTED:<span class="cov0" title="0">
                        return errors.New("the transaction hasn't been aborted")</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("the transaction isn't in the expected state %v", state)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (st *StateMachine) GetState() config.State <span class="cov8" title="1">{
        return st.state
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package txn

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/kkkzoz/oreo/pkg/config"
        "github.com/kkkzoz/oreo/pkg/locker"
)

type SourceType string

const (
        // EMPTY  SourceType = "EMPTY"
        LOCAL  SourceType = "LOCAL"
        GLOBAL SourceType = "GLOBAL"
)

// Transaction represents a transaction in the system.
// It contains information such as the transaction ID, state, timestamps,
// datastores, time source, oracle URL, and locker.
type Transaction struct {
        // TxnId is the unique identifier for the transaction.
        TxnId string
        // TxnStartTime is the timestamp when the transaction started.
        TxnStartTime time.Time
        // TxnCommitTime is the timestamp when the transaction was committed.
        TxnCommitTime time.Time

        // tsrMaintainer is used to maintain the TSR (Transaction Status Record)
        // TSRMaintainer is responsible for handling and updating the status of transactions.
        tsrMaintainer TSRMaintainer
        // dataStoreMap is a map of transaction-specific datastores.
        dataStoreMap map[string]Datastore
        // timeSource represents the source of time for the transaction.
        timeSource SourceType
        // oracleURL is the URL of the oracle service used by the transaction.
        oracleURL string
        // locker is used for transaction-level locking.
        locker locker.Locker

        *StateMachine
}

// NewTransaction creates a new Transaction object.
// It initializes the Transaction with default values and returns a pointer to the newly created object.
func NewTransaction() *Transaction <span class="cov0" title="0">{
        return &amp;Transaction{
                TxnId:        "",
                dataStoreMap: make(map[string]Datastore),
                timeSource:   LOCAL,
                locker:       locker.AMemoryLocker,
                StateMachine: NewStateMachine(),
        }
}</span>

// Start begins the transaction.
// It checks if the transaction is already started and returns an error if so.
// It also checks if the necessary datastores are added and returns an error if not.
// It sets the transaction state to STARTED and generates a unique transaction ID.
// It starts each datastore associated with the transaction.
// Returns an error if any of the above steps fail, otherwise returns nil.
func (t *Transaction) Start() error <span class="cov0" title="0">{
        err := t.SetState(config.STARTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check nessary datastores are added
        <span class="cov0" title="0">if t.tsrMaintainer == nil </span><span class="cov0" title="0">{
                return errors.New("global datastore not set")
        }</span>
        <span class="cov0" title="0">if len(t.dataStoreMap) == 0 </span><span class="cov0" title="0">{
                return errors.New("no datastores added")
        }</span>
        <span class="cov0" title="0">t.TxnId = uuid.NewString()
        t.TxnStartTime, err = t.getTime()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, ds := range t.dataStoreMap </span><span class="cov0" title="0">{
                err := ds.Start()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AddDatastore adds a datastore to the transaction.
// It checks if the datastore name is duplicated and returns an error if it is.
// Otherwise, it sets the transaction for the datastore and adds it to the transaction's datastore map.
func (t *Transaction) AddDatastore(ds Datastore) error <span class="cov0" title="0">{
        // if name is duplicated
        if _, ok := t.dataStoreMap[ds.GetName()]; ok </span><span class="cov0" title="0">{
                return errors.New("duplicated datastore name")
        }</span>
        <span class="cov0" title="0">ds.SetTxn(t)
        t.dataStoreMap[ds.GetName()] = ds
        return nil</span>
}

// SetGlobalDatastore sets the global datastore for the transaction.
// It takes a Datastore parameter and assigns it to the globalDataStore field of the Transaction struct.
func (t *Transaction) SetGlobalDatastore(ds Datastore) <span class="cov0" title="0">{
        t.tsrMaintainer = ds.(TSRMaintainer)
}</span>

// Read reads the value associated with the given key from the specified datastore.
// It returns an error if the transaction is not in the STARTED state or if the datastore is not found.
func (t *Transaction) Read(dsName string, key string, value any) error <span class="cov0" title="0">{
        err := t.CheckState(config.STARTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if ds, ok := t.dataStoreMap[dsName]; ok </span><span class="cov0" title="0">{
                return ds.Read(key, value)
        }</span>
        <span class="cov0" title="0">return errors.New("datastore not found")</span>
}

// Write writes the given key-value pair to the specified datastore in the transaction.
// It returns an error if the transaction is not in the STARTED state or if the datastore is not found.
func (t *Transaction) Write(dsName string, key string, value any) error <span class="cov0" title="0">{
        err := t.CheckState(config.STARTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if ds, ok := t.dataStoreMap[dsName]; ok </span><span class="cov0" title="0">{
                return ds.Write(key, value)
        }</span>
        <span class="cov0" title="0">return errors.New("datastore not found")</span>
}

// Delete deletes a key from the specified datastore in the transaction.
// It returns an error if the transaction is not in the STARTED state or if the datastore is not found.
func (t *Transaction) Delete(dsName string, key string) error <span class="cov0" title="0">{
        err := t.CheckState(config.STARTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if ds, ok := t.dataStoreMap[dsName]; ok </span><span class="cov0" title="0">{
                return ds.Delete(key)
        }</span>
        <span class="cov0" title="0">return errors.New("datastore not found")</span>
}

// Commit commits the transaction.
// It checks the transaction state and performs the prepare phase.
// If the prepare phase fails, it aborts the transaction and returns an error.
// Otherwise, it proceeds to the commit phase and commits the transaction in all data stores.
// Finally, it deletes the transaction state record.
// Returns an error if any operation fails.
func (t *Transaction) Commit() error <span class="cov0" title="0">{

        err := t.SetState(config.COMMITTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Prepare phase
        <span class="cov0" title="0">t.TxnCommitTime, err = t.getTime()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">success := true
        var cause error
        for _, ds := range t.dataStoreMap </span><span class="cov0" title="0">{
                err := ds.Prepare()
                if err != nil </span><span class="cov0" title="0">{
                        success = false
                        cause = err
                        break</span>
                }
        }
        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                t.Abort()
                return errors.New("prepare phase failed: " + cause.Error())
        }</span>

        // Commit phase
        // The sync point
        <span class="cov0" title="0">txnState, err := t.GetTSRState(t.TxnId)
        if err == nil &amp;&amp; txnState == config.ABORTED </span><span class="cov0" title="0">{
                t.Abort()
                return errors.New("transaction is aborted by other transaction")
        }</span>

        <span class="cov0" title="0">err = t.WriteTSR(t.TxnId, config.COMMITTED)
        if err != nil </span><span class="cov0" title="0">{
                t.Abort()
                return err
        }</span>

        <span class="cov0" title="0">for _, ds := range t.dataStoreMap </span><span class="cov0" title="0">{
                // TODO: do not allow abort after Commit
                // try indefinitely until success
                ds.Commit()
        }</span>

        <span class="cov0" title="0">t.DeleteTSR()
        return nil</span>
}

// Abort aborts the transaction.
// It checks the current state of the transaction and returns an error if the transaction is already committed, aborted, or not started.
// If the transaction is in a valid state, it sets the transaction state to ABORTED and calls the Abort method on each data store associated with the transaction.
// Returns an error if any of the data store's Abort method returns an error, otherwise returns nil.
func (t *Transaction) Abort() error <span class="cov0" title="0">{
        lastState := t.GetState()
        err := t.SetState(config.ABORTED)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hasCommitted := false
        if lastState == config.COMMITTED </span><span class="cov0" title="0">{
                hasCommitted = true
        }</span>
        <span class="cov0" title="0">for _, ds := range t.dataStoreMap </span><span class="cov0" title="0">{
                ds.Abort(hasCommitted)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WriteTSR writes the Transaction State Record (TSR) for the given transaction ID and state.
// It uses the global data store to persist the TSR.
// The txnId parameter specifies the ID of the transaction.
// The txnState parameter specifies the state of the transaction.
// Returns an error if there was a problem writing the TSR.
func (t *Transaction) WriteTSR(txnId string, txnState config.State) error <span class="cov0" title="0">{
        return t.tsrMaintainer.WriteTSR(txnId, txnState)
}</span>

// DeleteTSR deletes the Transaction Status Record (TSR) associated with the Transaction.
// It calls the DeleteTSR method of the globalDataStore to perform the deletion.
// It returns an error if the deletion operation fails.
func (t *Transaction) DeleteTSR() error <span class="cov0" title="0">{
        return t.tsrMaintainer.DeleteTSR(t.TxnId)
}</span>

func (t *Transaction) GetTSRState(txnId string) (config.State, error) <span class="cov0" title="0">{
        return t.tsrMaintainer.ReadTSR(txnId)
}</span>

// SetGlobalTimeSource sets the global time source for the transaction.
// It takes a URL as a parameter and assigns it to the transaction's oracleURL field.
// The timeSource field is set to GLOBAL.
func (t *Transaction) SetGlobalTimeSource(url string) <span class="cov0" title="0">{
        t.timeSource = GLOBAL
        t.oracleURL = url
}</span>

// getTime returns the current time based on the time source configured in the Transaction.
// If the time source is set to LOCAL, it returns the current local time.
// If the time source is set to GLOBAL, it retrieves the time from the specified time URL.
// It returns the parsed time value and any error encountered during the process.
func (t *Transaction) getTime() (time.Time, error) <span class="cov0" title="0">{
        if t.timeSource == LOCAL </span><span class="cov0" title="0">{
                return time.Now(), nil
        }</span>
        <span class="cov0" title="0">if t.timeSource == GLOBAL </span><span class="cov0" title="0">{
                res, err := http.Get(t.oracleURL + "/time")
                if err != nil </span><span class="cov0" title="0">{
                        return time.Now(), errors.New("failed to get time from global time source")
                }</span>

                <span class="cov0" title="0">var timeString string
                fmt.Fscan(res.Body, &amp;timeString)
                return time.Parse(time.RFC3339, timeString)</span>
        }
        <span class="cov0" title="0">return time.Now(), nil</span>
}

// SetLocker sets the locker for the transaction.
// The locker is responsible for managing the concurrency of the transaction.
// It ensures that only one goroutine can access the transaction at a time.
// The locker must implement the locker.Locker interface.
func (t *Transaction) SetLocker(locker locker.Locker) <span class="cov0" title="0">{
        t.locker = locker
}</span>

// Lock locks the specified key with the given ID for the specified duration.
// If the locker is not set, it returns an error.
func (t *Transaction) Lock(key string, id string, duration time.Duration) error <span class="cov0" title="0">{
        if t.locker == nil </span><span class="cov0" title="0">{
                return errors.New("locker not set")
        }</span>
        <span class="cov0" title="0">return t.locker.Lock(key, id, duration)</span>
}

// Unlock unlocks the specified key with the given ID.
// It returns an error if the locker is not set or if unlocking fails.
func (t *Transaction) Unlock(key string, id string) error <span class="cov0" title="0">{
        if t.locker == nil </span><span class="cov0" title="0">{
                return errors.New("locker not set")
        }</span>
        <span class="cov0" title="0">return t.locker.Unlock(key, id)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
